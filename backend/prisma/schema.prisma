generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String                @id @default(cuid())
  username               String                @unique
  displayName            String?
  email                  String?               @unique
  passwordHash           String
  subsonicPassword       String? // Encrypted plaintext for Subsonic token auth (md5 requires plaintext)
  role                   String                @default("user")
  onboardingComplete     Boolean               @default(false)
  enrichmentSettings     Json?
  twoFactorEnabled       Boolean               @default(false)
  twoFactorSecret        String?
  twoFactorRecoveryCodes String?
  profilePicture         Bytes?
  moodMixParams          Json?
  tokenVersion           Int                   @default(0)
  createdAt              DateTime              @default(now())
  apiKeys                ApiKey[]
  audiobookProgress      AudiobookProgress[]
  cachedTracks           CachedTrack[]
  deviceLinkCodes        DeviceLinkCode[]
  discoverExclusions     DiscoverExclusion[]
  discoveryAlbums        DiscoveryAlbum[]
  dislikedEntities       DislikedEntity[]
  downloadJobs           DownloadJob[]
  hiddenPlaylists        HiddenPlaylist[]
  likedTracks            LikedTrack[]
  listeningState         ListeningState[]
  notifications          Notification[]
  plays                  Play[]
  playbackStates         PlaybackState[]
  playlists              Playlist[]
  podcastDownloads       PodcastDownload[]
  podcastProgress        PodcastProgress[]
  podcastSubscriptions   PodcastSubscription[]
  spotifyImportJobs      SpotifyImportJob[]
  unavailableAlbums      UnavailableAlbum[]
  syncGroupsHosted       SyncGroup[]           @relation("SyncGroupHost")
  syncGroupMemberships   SyncGroupMember[]
  discoverConfig         UserDiscoverConfig?
  userMoodMix            UserMoodMix?
  settings               UserSettings?
  inviteCodesCreated     InviteCode[]          @relation("InviteCodesCreated")
  inviteCodeUsed         InviteCodeUsage?      @relation("InviteCodeUsed")
}

model UserSettings {
  userId                String  @id
  playbackQuality       String  @default("original")
  shareOnlinePresence   Boolean @default(false)
  shareListeningStatus  Boolean @default(false)
  wifiOnly              Boolean @default(false)
  offlineEnabled        Boolean @default(false)
  maxCacheSizeMb        Int     @default(10240)
  // YouTube Music — per-user OAuth credentials and quality preference
  ytMusicOAuthJson      String? // Encrypted OAuth token JSON from ytmusicapi
  ytMusicQuality        String  @default("HIGH")
  // Per-user TIDAL streaming
  tidalOAuthJson        String? // Encrypted JSON with access_token, refresh_token, user_id, country_code
  tidalStreamingQuality String  @default("HIGH")
  user                  User    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model InviteCode {
  id        String            @id @default(cuid())
  code      String            @unique
  createdBy String
  expiresAt DateTime?
  maxUses   Int               @default(1)
  useCount  Int               @default(0)
  revoked   Boolean           @default(false)
  createdAt DateTime          @default(now())
  creator   User              @relation("InviteCodesCreated", fields: [createdBy], references: [id], onDelete: Cascade)
  usages    InviteCodeUsage[]

  @@index([code])
  @@index([createdBy])
}

model InviteCodeUsage {
  id           String     @id @default(cuid())
  inviteCodeId String
  usedBy       String     @unique
  usedAt       DateTime   @default(now())
  inviteCode   InviteCode @relation(fields: [inviteCodeId], references: [id], onDelete: Cascade)
  user         User       @relation("InviteCodeUsed", fields: [usedBy], references: [id], onDelete: Cascade)

  @@index([inviteCodeId])
  @@index([usedBy])
}

model PlaybackState {
  userId       String
  deviceId     String   @default("legacy")
  playbackType String
  trackId      String?
  audiobookId  String?
  podcastId    String?
  queue        Json?
  currentIndex Int      @default(0)
  isShuffle    Boolean  @default(false)
  isPlaying    Boolean  @default(false)
  currentTime  Float    @default(0)
  updatedAt    DateTime @updatedAt
  createdAt    DateTime @default(now())
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, deviceId])
  @@index([userId, updatedAt])
}

model SyncGroup {
  id         String  @id @default(cuid())
  name       String  @default("Listen Together")
  joinCode   String  @unique
  groupType  String  @default("host-follower") // "host-follower" | "collaborative"
  visibility String  @default("public") // "public" | "private"
  hostUserId String
  isActive   Boolean @default(true)

  // Playback state (persisted periodically from in-memory manager)
  trackId        String?
  queue          Json? // Array of SyncQueueItem objects
  currentIndex   Int      @default(0)
  isPlaying      Boolean  @default(false)
  currentTime    Float    @default(0)
  stateVersion   Int      @default(0) // Monotonic counter
  stateUpdatedAt DateTime @default(now())

  endedAt   DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Relations
  hostUser User              @relation("SyncGroupHost", fields: [hostUserId], references: [id], onDelete: Cascade)
  track    Track?            @relation("SyncGroupTrack", fields: [trackId], references: [id], onDelete: SetNull)
  members  SyncGroupMember[]

  @@index([hostUserId, isActive])
  @@index([isActive, visibility, updatedAt])
}

model SyncGroupMember {
  id          String    @id @default(cuid())
  syncGroupId String
  userId      String
  isHost      Boolean   @default(false)
  joinedAt    DateTime  @default(now())
  lastSeenAt  DateTime  @updatedAt
  leftAt      DateTime?

  syncGroup SyncGroup @relation(fields: [syncGroupId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([syncGroupId, userId])
  @@index([userId, leftAt])
  @@index([syncGroupId, leftAt])
}

model SystemSettings {
  id                          String   @id @default("default")
  lidarrEnabled               Boolean  @default(false)
  lidarrUrl                   String?  @default("http://localhost:8686")
  lidarrApiKey                String?
  openaiEnabled               Boolean  @default(false)
  openaiApiKey                String?
  openaiModel                 String?  @default("gpt-4")
  openaiBaseUrl               String?
  fanartEnabled               Boolean  @default(false)
  fanartApiKey                String?
  audiobookshelfEnabled       Boolean  @default(false)
  audiobookshelfUrl           String?  @default("http://localhost:13378")
  audiobookshelfApiKey        String?
  soulseekUsername            String?
  soulseekPassword            String?
  spotifyClientId             String?
  spotifyClientSecret         String?
  // TIDAL integration (via tiddl Python sidecar)
  tidalEnabled                Boolean  @default(false)
  tidalAccessToken            String?
  tidalRefreshToken           String?
  tidalUserId                 String?
  tidalCountryCode            String?  @default("US")
  tidalQuality                String?  @default("HIGH")
  tidalFileTemplate           String?  @default("{album.artist}/{album.title}/{item.number:02d}. {item.title}")
  musicPath                   String?  @default("/music")
  downloadPath                String?  @default("/downloads")
  autoSync                    Boolean  @default(true)
  autoEnrichMetadata          Boolean  @default(true)
  libraryDeletionEnabled      Boolean  @default(false)
  maxConcurrentDownloads      Int      @default(3)
  downloadRetryAttempts       Int      @default(3)
  transcodeCacheMaxGb         Int      @default(10)
  downloadSource              String   @default("soulseek")
  primaryFailureFallback      String   @default("none")
  updatedAt                   DateTime @updatedAt
  createdAt                   DateTime @default(now())
  enrichmentConcurrency       Int      @default(1)
  lidarrWebhookSecret         String?
  audioAnalyzerWorkers        Int      @default(2)
  clapWorkers                 Int      @default(2)
  lastfmApiKey                String?
  soulseekConcurrentDownloads Int      @default(4)
  // YouTube Music streaming — admin toggle + OAuth app credentials
  ytMusicEnabled              Boolean  @default(false)
  ytMusicClientId             String? // Google OAuth client ID (TVs and Limited Input devices)
  ytMusicClientSecret         String? // Google OAuth client secret
  discNoBackfillDone          Boolean  @default(false)
  showVersion                 Boolean  @default(false)
}

model Artist {
  id                  String                   @id @default(cuid())
  mbid                String                   @unique
  name                String
  normalizedName      String                   @default("")
  summary             String?
  heroUrl             String?
  genres              Json?
  lastSynced          DateTime                 @default(now())
  lastEnriched        DateTime?
  enrichmentStatus    String                   @default("pending")
  searchVector        Unsupported("tsvector")?
  similarArtistsJson  Json?
  displayName         String?
  hasUserOverrides    Boolean                  @default(false)
  userGenres          Json?
  userHeroUrl         String?
  userSummary         String?
  countsLastUpdated   DateTime?
  discoveryAlbumCount Int                      @default(0)
  libraryAlbumCount   Int                      @default(0)
  totalTrackCount     Int                      @default(0)
  albums              Album[]
  ownedAlbums         OwnedAlbum[]
  similarFrom         SimilarArtist[]          @relation("FromArtist")
  similarTo           SimilarArtist[]          @relation("ToArtist")

  @@index([name])
  @@index([normalizedName])
  @@index([searchVector], type: Gin)
  @@index([hasUserOverrides])
  @@index([libraryAlbumCount])
  @@index([discoveryAlbumCount])
  @@index([totalTrackCount])
}

model Album {
  id               String                   @id @default(cuid())
  rgMbid           String                   @unique
  artistId         String
  title            String
  year             Int?
  coverUrl         String?
  primaryType      String
  label            String?
  genres           Json?
  lastSynced       DateTime                 @default(now())
  location         AlbumLocation            @default(LIBRARY)
  searchVector     Unsupported("tsvector")?
  displayTitle     String?
  displayYear      Int?
  hasUserOverrides Boolean                  @default(false)
  userCoverUrl     String?
  userGenres       Json?
  originalYear     Int?
  artist           Artist                   @relation(fields: [artistId], references: [id], onDelete: Cascade)
  tracks           Track[]

  @@index([artistId])
  @@index([location])
  @@index([artistId, location])
  @@index([title])
  @@index([searchVector], type: Gin)
  @@index([hasUserOverrides])
}

model Track {
  id                 String                   @id @default(cuid())
  albumId            String
  title              String
  trackNo            Int
  discNo             Int                      @default(1)
  duration           Int
  mime               String?
  searchVector       Unsupported("tsvector")?
  filePath           String                   @unique
  fileModified       DateTime
  fileSize           Int
  bpm                Float?
  beatsCount         Int?
  key                String?
  keyScale           String?
  keyStrength        Float?
  energy             Float?
  loudness           Float?
  dynamicRange       Float?
  danceability       Float?
  valence            Float?
  arousal            Float?
  instrumentalness   Float?
  acousticness       Float?
  speechiness        Float?
  // Legacy mood fields - populated by MusiCNN analyzer
  // These may be derived from CLAP text-anchor similarity in future
  // Consider removing in v2.0 if vibe similarity fully replaces mood-based features
  moodHappy          Float?
  moodSad            Float?
  moodRelaxed        Float?
  moodAggressive     Float?
  moodParty          Float?
  moodAcoustic       Float?
  moodElectronic     Float?
  danceabilityMl     Float?
  moodTags           String[]
  essentiaGenres     String[]
  lastfmTags         String[]
  analysisStatus     String                   @default("pending")
  analysisVersion    String?
  analysisMode       String?
  analyzedAt         DateTime?
  analysisError      String?
  analysisRetryCount Int                      @default(0)
  updatedAt          DateTime                 @updatedAt
  displayTitle       String?
  displayTrackNo     Int?
  hasUserOverrides   Boolean                  @default(false)
  analysisStartedAt  DateTime?

  // Vibe analysis status tracking
  vibeAnalysisStatus          String? // Analysis status: pending, processing, completed, failed
  vibeAnalysisStartedAt       DateTime?
  vibeAnalysisError           String?
  vibeAnalysisRetryCount      Int       @default(0)
  vibeAnalysisStatusUpdatedAt DateTime? // When the status was last updated

  cachedBy        CachedTrack[]
  likedBy         LikedTrack[]
  mappings        TrackMapping[]
  moodBuckets     MoodBucket[]
  plays           Play[]
  playlistItems   PlaylistItem[]
  album           Album            @relation(fields: [albumId], references: [id], onDelete: Cascade)
  trackGenres     TrackGenre[]
  transcodedFiles TranscodedFile[]
  embedding       TrackEmbedding?
  lyrics          TrackLyrics?
  syncGroups      SyncGroup[]      @relation("SyncGroupTrack")

  @@index([albumId])
  @@index([albumId, discNo, trackNo])
  @@index([fileModified])
  @@index([title])
  @@index([searchVector], type: Gin)
  @@index([analysisStatus])
  @@index([analysisMode])
  @@index([bpm])
  @@index([energy])
  @@index([valence])
  @@index([danceability])
  @@index([moodHappy])
  @@index([moodSad])
  @@index([moodRelaxed])
  @@index([moodAggressive])
  @@index([moodParty])
  @@index([moodAcoustic])
  @@index([moodElectronic])
  @@index([arousal])
  @@index([acousticness])
  @@index([instrumentalness])
  @@index([hasUserOverrides])
}

model TranscodedFile {
  id             String   @id @default(cuid())
  trackId        String
  quality        String
  cachePath      String   @unique
  cacheSize      Int
  sourceModified DateTime
  lastAccessed   DateTime @default(now())
  createdAt      DateTime @default(now())
  track          Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)

  @@unique([trackId, quality])
  @@index([trackId, quality])
  @@index([lastAccessed])
}

model Play {
  id       String       @id @default(cuid())
  userId   String
  trackId  String
  playedAt DateTime     @default(now())
  source   ListenSource @default(LIBRARY)
  track    Track        @relation(fields: [trackId], references: [id], onDelete: Cascade)
  user     User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, playedAt])
  @@index([trackId])
  @@index([source])
}

model Playlist {
  id                 String                 @id @default(cuid())
  userId             String
  mixId              String?
  name               String
  isPublic           Boolean                @default(false)
  createdAt          DateTime               @default(now())
  updatedAt          DateTime               @default(now())
  spotifyPlaylistId  String?
  spotifyPlaylistUrl String?
  hiddenByUsers      HiddenPlaylist[]
  user               User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  items              PlaylistItem[]
  pendingTracks      PlaylistPendingTrack[]

  @@unique([userId, mixId])
  @@index([userId])
  @@index([spotifyPlaylistId])
}

model HiddenPlaylist {
  id         String   @id @default(cuid())
  userId     String
  playlistId String
  createdAt  DateTime @default(now())
  playlist   Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, playlistId])
  @@index([userId])
}

model PlaylistItem {
  id             String        @id @default(cuid())
  playlistId     String
  trackId        String?
  trackTidalId   String?
  trackYtMusicId String?
  sort           Int
  playlist       Playlist      @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  track          Track?        @relation(fields: [trackId], references: [id], onDelete: Cascade)
  trackTidal     TrackTidal?   @relation(fields: [trackTidalId], references: [id], onDelete: SetNull)
  trackYtMusic   TrackYtMusic? @relation(fields: [trackYtMusicId], references: [id], onDelete: SetNull)

  @@unique([playlistId, trackId])
  @@index([playlistId, sort])
  @@index([trackTidalId])
  @@index([trackYtMusicId])
}

/// @deprecated Use PlaylistItem with trackTidalId/trackYtMusicId instead.
/// Retained for backward compatibility with legacy Spotify imports.
/// No new rows should be written. Table will be dropped in a future migration.
model PlaylistPendingTrack {
  id               String   @id @default(cuid())
  playlistId       String
  spotifyArtist    String
  spotifyTitle     String
  spotifyAlbum     String
  albumMbid        String?
  artistMbid       String?
  deezerPreviewUrl String?
  sort             Int
  createdAt        DateTime @default(now())
  playlist         Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)

  @@unique([playlistId, spotifyArtist, spotifyTitle])
  @@index([playlistId])
  @@index([albumMbid])
  @@index([artistMbid])
}

model SpotifyImportJob {
  id                 String   @id
  userId             String
  spotifyPlaylistId  String
  playlistName       String
  status             String
  progress           Int      @default(0)
  albumsTotal        Int
  albumsCompleted    Int      @default(0)
  tracksTotal        Int
  tracksMatched      Int      @default(0)
  tracksDownloadable Int      @default(0)
  createdPlaylistId  String?
  error              String?
  pendingTracks      Json
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

model Genre {
  id          String       @id @default(cuid())
  name        String       @unique
  trackGenres TrackGenre[]
}

model TrackGenre {
  trackId String
  genreId String
  genre   Genre  @relation(fields: [genreId], references: [id], onDelete: Cascade)
  track   Track  @relation(fields: [trackId], references: [id], onDelete: Cascade)

  @@id([trackId, genreId])
  @@index([genreId])
}

model SimilarArtist {
  fromArtistId String
  toArtistId   String
  weight       Float  @default(1.0)
  fromArtist   Artist @relation("FromArtist", fields: [fromArtistId], references: [id], onDelete: Cascade)
  toArtist     Artist @relation("ToArtist", fields: [toArtistId], references: [id], onDelete: Cascade)

  @@id([fromArtistId, toArtistId])
  @@index([fromArtistId])
}

model OwnedAlbum {
  artistId String
  rgMbid   String
  source   String
  artist   Artist @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@id([artistId, rgMbid])
  @@index([artistId])
}

model DownloadJob {
  id               String          @id @default(cuid())
  correlationId    String?         @unique
  userId           String
  subject          String
  type             String
  targetMbid       String
  status           String
  error            String?
  lidarrRef        String?
  lidarrAlbumId    Int?
  metadata         Json?
  attempts         Int             @default(0)
  startedAt        DateTime?
  completedAt      DateTime?
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  discoveryBatchId String?
  triedReleases    String[]        @default([])
  releaseIndex     Int             @default(0)
  artistMbid       String?
  cleared          Boolean         @default(false)
  discoveryBatch   DiscoveryBatch? @relation(fields: [discoveryBatchId], references: [id])
  user             User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, status])
  @@index([status])
  @@index([discoveryBatchId])
  @@index([correlationId])
  @@index([startedAt])
  @@index([lidarrRef])
  @@index([artistMbid])
  @@index([targetMbid])
}

model ListeningState {
  id         String   @id @default(cuid())
  userId     String
  kind       String
  entityId   String
  trackId    String?
  positionMs Int      @default(0)
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, kind, entityId])
  @@index([userId])
}

model DiscoveryAlbum {
  id            String           @id @default(cuid())
  userId        String
  rgMbid        String
  artistName    String
  artistMbid    String?
  albumTitle    String
  lidarrAlbumId Int?
  downloadedAt  DateTime?
  folderPath    String           @default("")
  weekStartDate DateTime
  weekEndDate   DateTime         @default(now())
  status        DiscoverStatus   @default(ACTIVE)
  likedAt       DateTime?
  similarity    Float?
  tier          String?
  user          User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  tracks        DiscoveryTrack[]

  @@unique([userId, weekStartDate, rgMbid])
  @@index([userId, weekStartDate])
  @@index([downloadedAt])
  @@index([status])
}

model DiscoveryTrack {
  id               String         @id @default(cuid())
  discoveryAlbumId String
  trackId          String?
  fileName         String
  filePath         String
  inPlaylistCount  Int            @default(0)
  userKept         Boolean        @default(false)
  lastPlayedAt     DateTime?
  discoveryAlbum   DiscoveryAlbum @relation(fields: [discoveryAlbumId], references: [id], onDelete: Cascade)

  @@index([discoveryAlbumId])
  @@index([userKept])
  @@index([lastPlayedAt])
}

model LikedTrack {
  userId  String
  trackId String
  likedAt DateTime @default(now())
  track   Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, trackId])
  @@index([userId])
  @@index([likedAt])
}

model DislikedEntity {
  id         String   @id @default(cuid())
  userId     String
  entityType String
  entityId   String
  dislikedAt DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, entityType, entityId])
  @@index([userId, entityType])
}

model CachedTrack {
  id             String   @id @default(cuid())
  userId         String
  trackId        String
  localPath      String
  quality        String
  fileSizeMb     Float
  cachedAt       DateTime @default(now())
  lastAccessedAt DateTime @default(now())
  track          Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, trackId, quality])
  @@index([userId])
  @@index([lastAccessedAt])
}

model AudiobookProgress {
  id               String   @id @default(cuid())
  userId           String
  audiobookshelfId String
  title            String
  author           String?
  coverUrl         String?
  currentTime      Float    @default(0)
  duration         Float    @default(0)
  isFinished       Boolean  @default(false)
  lastPlayedAt     DateTime @default(now())
  updatedAt        DateTime @updatedAt
  createdAt        DateTime @default(now())
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, audiobookshelfId])
  @@index([userId, lastPlayedAt])
}

model Audiobook {
  id             String                   @id
  title          String
  author         String?
  narrator       String?
  description    String?
  publishedYear  Int?
  publisher      String?
  series         String?
  seriesSequence String?
  duration       Float?
  numTracks      Int?
  numChapters    Int?
  size           BigInt?
  isbn           String?
  asin           String?
  language       String?
  genres         String[]
  tags           String[]
  localCoverPath String?
  coverUrl       String?
  audioUrl       String
  libraryId      String?
  createdAt      DateTime                 @default(now())
  updatedAt      DateTime                 @updatedAt
  lastSyncedAt   DateTime                 @default(now())
  searchVector   Unsupported("tsvector")?

  @@index([title])
  @@index([author])
  @@index([series])
  @@index([lastSyncedAt])
  @@index([searchVector], type: Gin)
}

model PodcastRecommendation {
  id            String   @id @default(cuid())
  podcastId     String
  recommendedId String
  title         String
  author        String?
  description   String?
  coverUrl      String?
  episodeCount  Int      @default(0)
  feedUrl       String?
  itunesId      String?
  score         Float    @default(0)
  cachedAt      DateTime @default(now())
  expiresAt     DateTime

  @@index([podcastId, expiresAt])
  @@index([expiresAt])
  @@map("podcast_recommendations")
}

model Podcast {
  id              String                   @id @default(cuid())
  feedUrl         String                   @unique
  title           String
  author          String?
  description     String?
  imageUrl        String?
  localCoverPath  String?
  itunesId        String?                  @unique
  language        String?
  explicit        Boolean                  @default(false)
  episodeCount    Int                      @default(0)
  lastRefreshed   DateTime                 @default(now())
  refreshInterval Int                      @default(3600)
  autoRefresh     Boolean                  @default(true)
  createdAt       DateTime                 @default(now())
  updatedAt       DateTime                 @updatedAt
  searchVector    Unsupported("tsvector")?
  episodes        PodcastEpisode[]
  subscriptions   PodcastSubscription[]

  @@index([itunesId])
  @@index([lastRefreshed])
  @@index([searchVector], type: Gin)
}

model PodcastEpisode {
  id             String                   @id @default(cuid())
  podcastId      String
  guid           String
  title          String
  description    String?
  audioUrl       String
  duration       Int                      @default(0)
  publishedAt    DateTime
  episodeNumber  Int?
  season         Int?
  imageUrl       String?
  localCoverPath String?
  fileSize       Int?
  mimeType       String?                  @default("audio/mpeg")
  createdAt      DateTime                 @default(now())
  searchVector   Unsupported("tsvector")?
  downloads      PodcastDownload[]
  podcast        Podcast                  @relation(fields: [podcastId], references: [id], onDelete: Cascade)
  progress       PodcastProgress[]

  @@unique([podcastId, guid])
  @@index([podcastId, publishedAt])
  @@index([searchVector], type: Gin)
}

model PodcastSubscription {
  userId       String
  podcastId    String
  subscribedAt DateTime @default(now())
  podcast      Podcast  @relation(fields: [podcastId], references: [id], onDelete: Cascade)
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, podcastId])
  @@index([userId])
  @@index([podcastId])
}

model PodcastProgress {
  id           String         @id @default(cuid())
  userId       String
  episodeId    String
  currentTime  Float          @default(0)
  duration     Float          @default(0)
  isFinished   Boolean        @default(false)
  lastPlayedAt DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  createdAt    DateTime       @default(now())
  episode      PodcastEpisode @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  user         User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, episodeId])
  @@index([userId, lastPlayedAt])
}

model PodcastDownload {
  id             String         @id @default(cuid())
  userId         String
  episodeId      String
  localPath      String
  fileSizeMb     Float
  downloadedAt   DateTime       @default(now())
  lastAccessedAt DateTime       @default(now())
  episode        PodcastEpisode @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, episodeId])
  @@index([userId])
  @@index([lastAccessedAt])
}

model DiscoverExclusion {
  id              String   @id @default(cuid())
  userId          String
  albumMbid       String
  artistName      String?
  albumTitle      String?
  lastSuggestedAt DateTime @default(now())
  expiresAt       DateTime
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, albumMbid])
  @@index([userId, expiresAt])
}

model UserDiscoverConfig {
  id               String    @id @default(cuid())
  userId           String    @unique
  playlistSize     Int       @default(40)
  maxRetryAttempts Int       @default(3)
  exclusionMonths  Int       @default(6)
  downloadRatio    Float     @default(1.3)
  enabled          Boolean   @default(true)
  lastGeneratedAt  DateTime?
  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model UnavailableAlbum {
  id              String   @id @default(cuid())
  userId          String
  artistName      String
  albumTitle      String
  albumMbid       String
  artistMbid      String?
  similarity      Float
  tier            String
  weekStartDate   DateTime
  previewUrl      String?
  deezerTrackId   String?
  deezerAlbumId   String?
  attemptNumber   Int      @default(0)
  originalAlbumId String?
  createdAt       DateTime @default(now())
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, weekStartDate, albumMbid])
  @@index([userId, weekStartDate])
  @@index([userId, weekStartDate, attemptNumber])
  @@index([originalAlbumId])
}

model DiscoveryBatch {
  id              String        @id @default(cuid())
  userId          String
  weekStart       DateTime
  targetSongCount Int
  status          String        @default("downloading")
  totalAlbums     Int           @default(0)
  completedAlbums Int           @default(0)
  failedAlbums    Int           @default(0)
  finalSongCount  Int           @default(0)
  logs            Json?
  errorMessage    String?
  createdAt       DateTime      @default(now())
  completedAt     DateTime?
  jobs            DownloadJob[]

  @@index([userId, weekStart])
  @@index([status])
  @@index([createdAt])
}

model ApiKey {
  id        String   @id @default(cuid())
  userId    String
  key       String   @unique
  name      String
  lastUsed  DateTime @default(now())
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([key])
  @@index([userId])
  @@index([lastUsed])
}

model DeviceLinkCode {
  id         String    @id @default(cuid())
  code       String    @unique
  userId     String
  expiresAt  DateTime
  usedAt     DateTime?
  deviceName String?
  apiKeyId   String?
  createdAt  DateTime  @default(now())
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([code, expiresAt])
  @@index([userId])
}

model MoodBucket {
  id        String   @id @default(cuid())
  trackId   String
  mood      String
  score     Float
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  track     Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)

  @@unique([trackId, mood])
  @@index([mood, score(sort: Desc)])
  @@index([trackId])
}

model UserMoodMix {
  id          String   @id @default(cuid())
  userId      String   @unique
  mood        String
  trackIds    String[]
  coverUrls   String[]
  generatedAt DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  type      String
  title     String
  message   String?
  metadata  Json?
  read      Boolean  @default(false)
  cleared   Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, cleared])
  @@index([userId, read])
  @@index([createdAt])
}

model EnrichmentFailure {
  id            String    @id @default(cuid())
  entityType    String
  entityId      String
  entityName    String?
  errorMessage  String?
  errorCode     String?
  retryCount    Int       @default(0)
  maxRetries    Int       @default(3)
  firstFailedAt DateTime  @default(now())
  lastFailedAt  DateTime  @default(now())
  skipped       Boolean   @default(false)
  skippedAt     DateTime?
  resolved      Boolean   @default(false)
  resolvedAt    DateTime?
  metadata      Json?

  @@unique([entityType, entityId])
  @@index([entityType, resolved])
  @@index([skipped])
  @@index([lastFailedAt])
}

enum DiscoverStatus {
  ACTIVE
  LIKED
  MOVED
  DELETED
}

enum ListenSource {
  LIBRARY
  DISCOVERY
  DISCOVERY_KEPT
}

enum AlbumLocation {
  LIBRARY
  DISCOVER
}

model TrackLyrics {
  id           String   @id @default(cuid())
  trackId      String   @unique
  syncedLyrics String?  @db.Text
  plainLyrics  String?  @db.Text
  source       String // "lrclib", "embedded", "none"
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  track        Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)

  @@index([trackId])
}

model TrackEmbedding {
  trackId      String                     @id @map("track_id")
  embedding    Unsupported("vector(512)")
  modelVersion String                     @default("laion-clap-music") @map("model_version") @db.VarChar(50)
  analyzedAt   DateTime                   @default(now()) @map("analyzed_at") @db.Timestamptz
  track        Track                      @relation(fields: [trackId], references: [id], onDelete: Cascade)

  @@index([modelVersion])
  @@map("track_embeddings")
}

model TrackTidal {
  id            String         @id @default(cuid())
  tidalId       Int            @unique
  title         String
  artist        String
  album         String
  duration      Int
  isrc          String?
  quality       String?
  explicit      Boolean?
  createdAt     DateTime       @default(now())
  mappings      TrackMapping[]
  playlistItems PlaylistItem[]

  @@index([isrc])
}

model TrackYtMusic {
  id            String         @id @default(cuid())
  videoId       String         @unique
  title         String
  artist        String
  album         String
  duration      Int
  thumbnailUrl  String?
  createdAt     DateTime       @default(now())
  mappings      TrackMapping[]
  playlistItems PlaylistItem[]
}

model TrackMapping {
  id             String        @id @default(cuid())
  /// Active-row linkage uniqueness is enforced in SQL migrations:
  /// - stale=false rows are unique by (trackId, trackTidalId, trackYtMusicId)
  /// - at least one linkage key must be present
  trackId        String?
  trackTidalId   String?
  trackYtMusicId String?
  confidence     Float
  source         String        // "gap-fill" | "isrc" | "import-match" | "manual"
  stale          Boolean       @default(false)
  createdAt      DateTime      @default(now())
  track          Track?        @relation(fields: [trackId], references: [id], onDelete: SetNull)
  trackTidal     TrackTidal?   @relation(fields: [trackTidalId], references: [id], onDelete: SetNull)
  trackYtMusic   TrackYtMusic? @relation(fields: [trackYtMusicId], references: [id], onDelete: SetNull)

  @@index([trackId])
  @@index([trackTidalId])
  @@index([trackYtMusicId])
  @@index([stale])
}
